# GitHub Copilot Code Generation Instructions

## 0. Context & Ground Rules

This repo already contains a **mostly complete implementation** of Talk-To-My-Lawyer:

- Next.js App Router (TypeScript, SSR, Server Actions)
- Supabase (Auth, PostgreSQL, RLS)
- Stripe (subscriptions + letter allowances)
- AI letter generation
- Free trial system
- Employee coupons + commission tracking
- Secure admin portal at `/secure-admin-gateway`

**CRITICAL: Do not rebuild the app or create new architecture.**

- **Do NOT** create new folder structures
- **Do NOT** redesign the routing system
- **Do NOT** introduce new database schemas or table structures
- **Do NOT** replace existing components with new implementations
- **DO** extend the existing code by:
  - Adding new features to existing routes/components
  - Wiring up incomplete functionality
  - Hardening security and validation
  - Fixing bugs in current implementation
  - Migrating AI calls from Gemini to OpenAI (as specified)

**Always work within the current architecture. Extension only, never reconstruction.**

---

## 1) Tech Stack (As Implemented)

### Core

- **Next.js** (App Router, `app/` directory – see `package.json` for exact versions)
- **React + TypeScript**
- **Tailwind CSS + shadcn/ui** for UI components
- **Supabase**
  - Auth: email/password signups and logins
  - Database: PostgreSQL with migrations in `supabase/migrations/*.sql`
  - RLS policies and Postgres functions for business logic
- **Stripe**
  - Checkout sessions
  - Webhook/verification via `app/api/verify-payment/route.ts`

### AI Provider – Target State

- **Current code:** uses **Google Gemini** directly via `fetch` in:
  - `app/api/generate-letter/route.ts`
  - `app/api/letters/[id]/improve/route.ts`
- **Required direction:** migrate to **Supabase Edge Functions with OpenAI**, and then:
  - **Stop using Gemini entirely.**
  - Do not add any new Gemini-based code.
  - Create Supabase Edge Functions to handle AI generation server-side

**Architecture:**
- AI generation happens in Supabase Edge Functions (Deno runtime)
- Edge Functions call OpenAI API directly
- Next.js API routes invoke Edge Functions via `supabase.functions.invoke()`
- Keeps API keys secure and processing at the edge

---

## 2) Key Files & Folder Map

Copilot should assume this as the **source of truth**:

### App Routes

- Public & Auth:
  - `app/page.tsx` – marketing/landing
  - `app/auth/login/page.tsx`
  - `app/auth/signup/page.tsx` (subscriber/employee flows)

- Subscriber / Employee:
  - `app/dashboard/page.tsx` – role-based router for logged-in users
  - `app/dashboard/letters/page.tsx` – subscriber "My Letters" list
  - `app/dashboard/letters/new/page.tsx` – letter intake + submit form
  - `app/dashboard/letters/[id]/page.tsx` – single letter detail for subscriber
  - `app/dashboard/subscription/page.tsx` – subscription status & plans
  - `app/dashboard/commissions/page.tsx` – **employee** commissions overview
  - `app/dashboard/coupons/page.tsx` – **employee** coupon codes

- Legacy admin (do **not** extend):
  - `app/dashboard/admin/**` – **legacy admin views**, now blocked by middleware

- Secure admin portal (primary admin surface – **use this**):
  - `app/secure-admin-gateway/login/page.tsx` – dual-auth login (email/password + portal key)
  - `app/secure-admin-gateway/dashboard/page.tsx` – main admin dashboard (Review Queue, metrics)
  - `app/secure-admin-gateway/dashboard/letters/page.tsx` – admin Review Center
  - `app/secure-admin-gateway/dashboard/all-letters/page.tsx` – all letters
  - `app/secure-admin-gateway/dashboard/users/page.tsx` – all profiles
  - `app/secure-admin-gateway/dashboard/commissions/page.tsx` – commission overview
  - `app/secure-admin-gateway/dashboard/analytics/page.tsx` – analytics

### API Routes

- AI & letters:
  - `app/api/generate-letter/route.ts`
  - `app/api/letters/[id]/improve/route.ts`
  - `app/api/letters/[id]/approve/route.ts`
  - `app/api/letters/[id]/reject/route.ts`
  - `app/api/letters/[id]/start-review/route.ts`
  - `app/api/letters/[id]/submit/route.ts`
  - `app/api/letters/[id]/pdf/route.ts`
  - `app/api/letters/[id]/send-email/route.ts`
  - `app/api/letters/[id]/audit/route.ts`

- Auth / profile / admin:
  - `app/api/create-profile/route.ts`
  - `app/api/admin-auth/login/route.ts` – admin login handler
  - `app/api/admin/super-user/route.ts` – toggle subscriber `is_super_user` flag / list super users

- Stripe:
  - `app/api/create-checkout/route.ts`
  - `app/api/verify-payment/route.ts`

### Libraries

- Supabase:
  - `lib/supabase/server.ts` – server-side client
  - `lib/supabase/client.ts` – client-side client
  - `lib/supabase/middleware.ts` – session + role-aware middleware

- Auth:
  - `lib/auth/get-user.ts` – fetches Supabase session + profile
  - `lib/auth/admin-session.ts` – **separate secure admin session** (cookie-based)

- Types:
  - `lib/database.types.ts` – TS types for `Profile`, `Letter`, `Subscription`, `Commission`, etc.

### Components

- Core layout:
  - `components/dashboard-layout.tsx`

- Letters:
  - `components/review-letter-modal.tsx` – admin review & AI improvement UI
  - `components/review-status-modal.tsx` – subscriber review status timeline
  - `components/letter-actions.tsx` – PDF / email actions

- Subscription / Stripe:
  - `components/subscription-card.tsx`
  - `components/subscription-modal.tsx`
  - `components/payment-verifier.tsx`

- UI:
  - `components/ui/*` – shadcn components (Button, Card, Badge, Skeleton, etc.)

### Database & Migrations

- Primary schema & RLS:
  - `supabase/migrations/*.sql`
  - `COMPLETE_MIGRATION.sql` – reference snapshot (do **not** re-run)

- Important tables:
  - `profiles` – id, email, full_name, `role` (`subscriber` | `employee` | `admin`), `is_super_user`, etc.
  - `letters` – letter lifecycle
  - `letter_audit_trail` – review history
  - `subscriptions` – plan, status, letters remaining
  - `employee_coupons`, `coupon_usage`
  - `commissions`
  - `security_audit_log`, `security_config`

- Important functions:
  - `check_letter_allowance(u_id)` – decides if user can generate a letter (`has_allowance`, `remaining`, `plan_name`, `is_super`)
  - `log_letter_audit(...)` – append audit entries
  - various RLS policies for `profiles`, `letters`, `coupon_usage`, etc.

### Roles in `profiles.role`

- `'subscriber'`
  - Normal end-user
  - Access:
    - `/dashboard`
    - `/dashboard/letters`, `/dashboard/letters/new`, `/dashboard/letters/[id]`
    - `/dashboard/subscription`

- `'employee'`
  - Employee / affiliate
  - Access:
    - `/dashboard` → redirected to `/dashboard/commissions`
    - `/dashboard/commissions`
    - `/dashboard/coupons`
  - **Cannot see any letters data** (no direct access to `letters`).

- `'admin'`
  - **Exactly one admin user in the entire system**
  - Created via script: `scripts/create-admin-user.ts`
  - Logs in via: `/secure-admin-gateway/login`
  - Access:
    - `/secure-admin-gateway/dashboard` and its child routes
    - Admin-only APIs (e.g. `/api/admin/super-user`)

### Single Admin Rule

- There is **one** admin row in `profiles` (the seeded admin).
- **Do not**:
  - Create UI to promote users to `role = 'admin'`.
  - Allow signup as admin.
  - Create "super admin" / "super user admin" tiers.

- `profiles.is_super_user` **is not an admin role**. It is a **business flag** used for:
  - Unlimited letter allowances (e.g. 100% discount "super user" coupons).
  - Displayed in `app/dashboard/subscription/page.tsx` as "Super User Status".

- Copilot must **never** treat `is_super_user` as an authorization role.
  All admin auth checks must use **`role = 'admin'` only**.

---

## 4) Routing, Middleware & Sessions

### Middleware (`lib/supabase/middleware.ts` + `middleware.ts`)

- The root `middleware.ts` calls `updateSession(request)` from `lib/supabase/middleware.ts`.
- `updateSession` is responsible for:
  - Initializing Supabase SSR client.
  - Syncing auth cookies.
  - Fetching the user + role (from `profiles`).
  - Applying role-based routing and protection.

Key behaviors (Copilot must respect/extend):

1. **Admin Portal Protection**

   ```ts
   const adminPortalRoute = process.env.ADMIN_PORTAL_ROUTE || 'secure-admin-gateway'

   if (pathname.startsWith(`/${adminPortalRoute}`)) {
     // `/secure-admin-gateway/login` is public
     // All other routes must have a valid admin session cookie
   }
   ```

   - Uses `verifyAdminSessionFromRequest(request)` from `lib/auth/admin-session.ts`.
   - If no valid admin session → redirect to `/secure-admin-gateway/login`.

2. **Block Legacy Admin Routes**

   ```ts
   if (pathname.startsWith('/dashboard/admin')) {
     // Always redirect to /dashboard
   }
   ```

   - Do not add new code under `/dashboard/admin/**`.
     All admin work lives under `/secure-admin-gateway/*`.

3. **Dashboard Protection**

   - If `!user` and `pathname.startsWith('/dashboard')` → redirect to `/auth/login`.
   - When at `/dashboard`, redirect based on `userRole`:
     - `admin` → now effectively goes through admin portal flows
     - `employee` → `/dashboard/commissions`
     - `subscriber` → stays on `/dashboard`

### Admin Session (`lib/auth/admin-session.ts`)

- Separate from Supabase auth.
- Uses cookie `admin_session` with:
  - `userId`
  - `email`
  - `loginTime`
  - `lastActivity`

- Login flow:
  - `app/secure-admin-gateway/login/page.tsx` POSTs to:
    - `/api/admin-auth/login`
  - `/api/admin-auth/login`:
    - Validates **email/password + portal key**.
    - Uses `verifyAdminCredentials` and `createAdminSession`.
    - Credentials & portal key are from env variables.

- In admin-only pages under `/secure-admin-gateway/dashboard/**`:
  - Check with `isAdminAuthenticated()` and/or rely on middleware guard.

**When adding or changing admin-only pages, enforce both:**

1. Path is under `/secure-admin-gateway/...`
2. Protected by admin session (middleware) and `role = 'admin'` in Supabase.

---

## 5) Letter Lifecycle & Status Flow

Letter statuses are defined in the `letter_status` enum and in `lib/database.types.ts`:

```ts
export type LetterStatus =
  | 'draft'
  | 'generating'
  | 'pending_review'
  | 'under_review'
  | 'approved'
  | 'completed'
  | 'rejected'
  | 'failed'
```

**Canonical flow:**

```text
draft → generating → pending_review → under_review → approved/rejected → completed/failed
```

Where:

- `draft`
  - User has started but not submitted letter for generation (may be implicit).

- `generating`
  - `/api/generate-letter` has created a record and is calling AI.

- `pending_review`
  - AI draft saved; waiting for admin review.

- `under_review`
  - Admin has opened the letter (see `start-review` API).

- `approved`
  - Admin approved final content.

- `rejected`
  - Admin rejected with a reason.

- `completed`
  - Fully processed: approved draft delivered (PDF/email).

- `failed`
  - AI generation or processing error.

**Audit Trail**

- Use `letter_audit_trail` and `log_letter_audit` Postgres function for:
  - status changes
  - approvals / rejections
  - failures

---

## 6) AI Integration – Supabase Edge Functions with OpenAI (NO GEMINI)

### Current Gemini Use (to be migrated)

1. `app/api/generate-letter/route.ts`
   - Creates `letters` row with `status = 'generating'`.
   - Calls **Google Gemini** via `fetch` using `GEMINI_API_KEY`.
   - On success:
     - Updates `letters` with `ai_draft_content` (or similar field).
     - Sets `status = 'pending_review'`.
     - Logs audit trail.
     - Returns `{ letterId, aiDraft, isFreeTrial }`.

2. `app/api/letters/[id]/improve/route.ts`
   - Accepts `content` + `instruction`.
   - Calls **Gemini** to rewrite/improve the letter.
   - Returns `{ improvedContent }`.

### Required Architecture

All AI generation must:

- Use **Supabase Edge Functions** (Deno runtime) to call **OpenAI API**
- Edge Functions located in `supabase/functions/`
- Use **`OPENAI_API_KEY`** env var (set in Supabase dashboard)
- Next.js API routes invoke Edge Functions via `supabase.functions.invoke()`
- **Completely remove** dependencies on `GEMINI_API_KEY` and Gemini endpoints from runtime code

### Edge Function Structure

Create two Edge Functions:

1. **`supabase/functions/generate-letter/index.ts`**
   - Accepts: `{ letterType, intakeData }` (JSON payload)
   - Calls OpenAI API with proper prompt
   - Returns: `{ success: true, content: string }` or `{ success: false, error: string }`

2. **`supabase/functions/improve-letter/index.ts`**
   - Accepts: `{ content, instruction }` (JSON payload)
   - Calls OpenAI API to improve/rewrite content
   - Returns: `{ success: true, improvedContent: string }` or `{ success: false, error: string }`

### Example Edge Function Implementation

File: `supabase/functions/generate-letter/index.ts`

```typescript
// Follow the imports and patterns for Supabase Edge Functions
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

const OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY')

serve(async (req) => {
  try {
    const { letterType, intakeData } = await req.json()

    // Build prompt based on letterType and intakeData
    const prompt = buildPrompt(letterType, intakeData)

    // Call OpenAI API
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4-turbo',
        messages: [
          {
            role: 'system',
            content: 'You are a professional legal drafting assistant.'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.7,
        max_tokens: 2048,
      }),
    })

    const data = await response.json()
    const content = data.choices[0].message.content

    return new Response(
      JSON.stringify({ success: true, content }),
      { headers: { 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    return new Response(
      JSON.stringify({ success: false, error: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  }
})

function buildPrompt(letterType: string, intakeData: any): string {
  // Implementation here - build proper legal letter prompt
  return `Generate a ${letterType} letter...`
}
```

### Next.js API Route Integration

**For `/api/generate-letter`**:

```typescript
import { createClient } from "@/lib/supabase/server"

const supabase = await createClient()

// Keep existing auth, free trial, and subscription checks
// Keep `letters` insert with `status = 'generating'`

// Call Edge Function instead of Gemini
const { data, error } = await supabase.functions.invoke('generate-letter', {
  body: {
    letterType: intakeData.letterType,
    intakeData: intakeData
  }
})

if (error || !data.success) {
  // Handle error, set status = 'failed'
  throw new Error(data?.error || 'AI generation failed')
}

// On success:
// - Update `letters` with data.content as AI draft
// - Set `status = 'pending_review'`
// - Log audit trail
// - Return `{ letterId, aiDraft: data.content, isFreeTrial }`
```

**For `/api/letters/[id]/improve`**:

```typescript
import { createClient } from "@/lib/supabase/server"

const supabase = await createClient()

// Keep current validation & auth

// Call Edge Function
const { data, error } = await supabase.functions.invoke('improve-letter', {
  body: {
    content: existingContent,
    instruction: improvementInstruction
  }
})

if (error || !data.success) {
  throw new Error(data?.error || 'AI improvement failed')
}

// Return `{ improvedContent: data.improvedContent }`
```

### Deployment Steps

1. Create Edge Functions:
   ```bash
   supabase functions new generate-letter
   supabase functions new improve-letter
   ```

2. Set environment variable in Supabase dashboard:
   - Navigate to Project Settings → Edge Functions
   - Add secret: `OPENAI_API_KEY`

3. Deploy functions:
   ```bash
   supabase functions deploy generate-letter
   supabase functions deploy improve-letter
   ```

4. Test functions:
   ```bash
   supabase functions invoke generate-letter --data '{"letterType":"demand","intakeData":{...}}'
   ```

### Rules

- Do **not** call OpenAI from Next.js API routes directly
- Do **not** call OpenAI from the client
- Do **not** add new Gemini usage anywhere
- Do **not** change the response shapes consumed by the frontend
- **All AI calls must go through Supabase Edge Functions**

---

## 7) Subscriber Flow – Letter Generation, Free Trial, Subscription

### New Letter Flow

Files:

- `app/dashboard/letters/new/page.tsx`
- `app/api/generate-letter/route.ts`
- `FREE_TRIAL_IMPLEMENTATION.md`

Behavior:

1. User fills out intake form:
   - Sender info
   - Recipient info
   - Issue description
   - Desired outcome
   - Letter type (`LETTER_TYPES` list)

2. On submit, client calls:

   ```ts
   const response = await fetch("/api/generate-letter", { ... })
   const { letterId, aiDraft, isFreeTrial } = await response.json()
   ```

3. After response:
   - Pushes to `/dashboard/letters/[id]?submitted=1`.
   - `ReviewStatusModal` handles the "Request received → Under attorney review → Posted to My Letters" timeline.

### Free Trial

- First letter is **free**:
  - `generate-letter` checks how many letters user has generated.
  - If zero → allow without subscription, set `isFreeTrial = true`.
  - Subsequent letters:
    - Require active subscription with remaining credits.
    - If missing, return `{ needsSubscription: true }` and **HTTP 403/400**, and frontend pushes user to `/dashboard/subscription`.

### Subscription & Letter Allowances

Relevant files:

- `app/dashboard/subscription/page.tsx`
- `app/api/create-checkout/route.ts`
- `app/api/verify-payment/route.ts`
- Migrations:
  - `005_letter_allowance_system.sql`
  - `009_add_missing_subscription_fields.sql`
  - `010_add_missing_functions.sql`
- `DATABASE_FUNCTIONS.md`

Plans (as per business logic):

- One-time: 1 letter
- Monthly / yearly equivalents with 4 / 8 letters (see migrations and docs)

**Function `check_letter_allowance(u_id)`**:

- Returns `has_allowance`, `remaining`, `plan_name`, `is_super`.
- Used server-side to decide whether a subscriber can generate another letter.

**Key expectations for Copilot:**

- Do not change the meaning of `credits_remaining`, `remaining_letters`, or `plan_type`.
- When adding new server logic around letter creation, reuse `check_letter_allowance` instead of duplicating queries.
- Respect `is_super` / `is_super_user` as "unlimited access" for subscribers, **not** as an admin role.

---

## 8) Employee Coupons & Commissions

### TypeScript

- Use strict TypeScript
- Define proper types for all data
- Use existing types from `/lib/database.types.ts`

### Components

- Use existing shadcn/ui components from `/components/ui/`
- Follow existing component patterns
- Keep components modular and reusable

### API Routes

- Use Next.js App Router conventions
- Implement proper error handling
- Return consistent JSON responses
- Check authentication first
- Validate input data

### Supabase Patterns

```typescript
// Always use server-side client for API routes
import { createClient } from "@/lib/supabase/server"

// Always check auth first
const supabase = await createClient()
const { data: { user }, error } = await supabase.auth.getUser()
if (error || !user) {
  return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
}
```

---

## 14) SECURITY BEST PRACTICES

### Row Level Security (RLS)

- Always enable RLS on tables
- Use `auth.uid()` for user-specific policies
- Create separate policies for each operation (SELECT, INSERT, UPDATE, DELETE)
- Use helper function `get_user_role()` for role checks

### Environment Variables

Required in `.env.local`:
- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- `SERVICE_ROLE_KEY`
- `OPENAI_API_KEY`
- `GEMINI_API_KEY`
- `STRIPE_SECRET_KEY`
- `NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY`

### Audit Trail

Always log important actions to `letter_audit_trail`:
```typescript
await supabase.rpc('log_letter_audit', {
  p_letter_id: letterId,
  p_action: 'approved',
  p_old_status: 'pending_review',
  p_new_status: 'approved',
  p_notes: 'Letter approved by admin'
})
```

---

## 15) EMPLOYEE COUPON SYSTEM

### Auto-Generation

- Trigger: When new employee profile created
- Format: `EMP-XXXXXX` (6 character hash)
- Discount: 20%
- Auto-active: `is_active = true`

### Commission Structure

- Commission rate: 5%
- Points: 1 point per use
- Status: `pending` → `paid`

---

## DEVELOPMENT ENVIRONMENT

This is a GitHub Codespaces environment with:
- Node.js 18+
- pnpm package manager
- PostgreSQL client tools
- Supabase CLI
- Python 3 (for Jupyter notebooks)
- Go, LLDB debugger support

Always respect the existing environment configuration and don't make assumptions about paths or tool availability.

---

## WORKING WITH THIS CODEBASE: EXTENSION, NOT RECONSTRUCTION

**The #1 rule: This is NOT a greenfield project.**

### What "Extension" Means

✅ **DO THIS:**
- Add new API endpoints in existing `app/api/` structure
- Create new components in `components/` following existing patterns
- Add new pages under existing route groups (`/dashboard/*`, `/secure-admin-gateway/*`)
- Extend database schema with NEW migrations in `supabase/migrations/`
- Wire up incomplete features (e.g., missing API calls)
- Add validation and error handling to existing functions
- Migrate Gemini → OpenAI in the two specified files

❌ **DO NOT DO THIS:**
- Create a new `/src` folder and move files there
- Redesign the routing from `/app` to something else
- Replace `components/ui/*` with a different UI library
- Drop and recreate existing database tables
- Rewrite working features "to make them better"
- Create `/app/admin` routes when `/secure-admin-gateway` exists
- Add new admin roles when the requirement is "single admin"

### When You See Incomplete Code

If you find:
- Missing error handling → **Add it to the existing function**
- Hardcoded values → **Extract to constants in existing files**
- TODO comments → **Implement the TODO in place**
- Unused functions → **Remove or wire them up**

Do NOT:
- Move the file to a "better" location
- Refactor the entire module
- Introduce new patterns that conflict with existing code

### Pattern Matching

Before writing new code:
1. **Search** for similar existing functionality
2. **Copy** the patterns you find (imports, error handling, typing)
3. **Extend** with your specific logic
4. **Stay consistent** with the rest of the file

Example: If every other API route uses `createClient()` from `@/lib/supabase/server`, your new route must too.

### File Organization

Existing structure you must respect:

```
app/
  api/              ← Server-side API routes
  auth/             ← Public auth pages
  dashboard/        ← Subscriber/employee areas
  secure-admin-gateway/  ← Admin-only area
components/         ← React components
  ui/               ← shadcn/ui primitives (DO NOT replace)
lib/
  auth/             ← Auth helpers
  supabase/         ← Supabase clients & middleware
  database.types.ts ← Generated types (DO NOT hand-edit)
supabase/migrations/ ← Database migrations (append only)
```

**If you need a new file, put it in the appropriate existing folder.**
